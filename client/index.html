<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=Edge"/>
	<meta name="description" content="Multi-player particle simulator"> 
	
	<title>Particle Sim</title>

	<Link rel="stylesheet" type="text/css" href="styleSheets/style.css"/>

	<Link rel="apple-touch-icon-precomposed" sizes="256x256" href="assets/particleSimLogo.png"/>
	<Link rel="shortcut icon" type="image/ico" href="favicon.ico"/>
	<Link rel="icon" type="image/ico" href="favicon.ico"/>

	<script src="/socket.io/socket.io.js"></script>
    <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
    <script type="text/babel">
        "use strict";
		
		let canvas = document.querySelector('canvas');
		let ctx = canvas.getContext('2d');
		
		var socket = {};

		// Flag for draw action underway
		let drawing = false;
		
		// Flag for touch based drawing underway
		let touchDrawing = false;

		// Flag for move action underway
		let moving = false;
		
		// Signals that drawing should be delayed till the action is determined to
		// actually be a drawing action
		let delayDrawing = false;
		
		let pixelSize = 4;
		let suggestedPixelSize;

		let clientSandArray = [];

		// Holds tiles to be sent to the server
		let outGoingTilesDict = {};
		// Holds tiles from the server to be applied to the scene
		let incomingTilesDict = {};
		// The program must wait a short time to determine if a touch event is a drawing action or a
		// panning/zooming action so tiles formed in this time must be stored here until they are confirmed
		// to be part of a drawing action.
		let tempTilesDict = {};
		// time given for touch action decisions
		const tempTime = 70;
		
		let clientScale = 1;
		let inverseClientScale = 1;
		
		// Scaled translate values
		let clientXTranslate = 0;
		let clientYTranslate = 0;
		
		// Unscaled translate values
		let unScaledclientXTranslate = 0;
		let unScaledclientYTranslate = 0;
		
		// Note: air = void = eraser
		const enumSandType = Object.freeze({
			air: 1,
			sand: 2,
			water: 3,
			salt: 4,
			stone: 5,
			saltWater: 6,
			seaweed: 7,
		});
		
		// Client copy of the scene lengths
		let sandArrayX = 0;
		let sandArrayY = 0;
		
		// The length in pixels, of the unscaled tiles
		let pixelHeight = 0;
		let pixelWidth = 0;
		
		// value of change in zoom
		let zoomValue = 1;
			
		// Currently selected particle type
		let drawColor = parseInt(document.querySelector("#sandType").value);
		
		// Last tile in which the mouse was located while drawing
		let lastPosition = {x: null, y: null};
		// Last position the mouse was located
		let lastMovePosition = {};
		// Last tile in which the mouse was seen hovering
		let lastIdlePosition = {x: null, y: null};
		// Last positions of fingers in pinch action
		let lastPinchData = {centerPt: null, magnitude: null};
		
		const boundingClient = canvas.getBoundingClientRect();
		
		// Math.sign is unsupported in IE so a custom version must be inserted
		// credit for sign code:
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
		if(!Math.sign){
			Math.sign = function(x){return typeof x === 'number' ? x ? x < 0 ? -1 : 1 : x === x ? 0 : NaN : NaN;};
		}
		
		// Object.assign is unsupported in IE so a custom version must be inserted
		// credit for assign code:
		// https://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically
		if(!Object.assign){
			Object.assign = function(obj1, obj2){for (let attrname in obj2) { obj1[attrname] = obj2[attrname]; }};
		}
		
		// Array.fill is unsupported in IE so a custom version must be inserted
		// credit for fill code (modified for ECMAScript 6):
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
		if (!Array.prototype.fill) {
			Object.defineProperty(Array.prototype, 'fill', {
				value: function(value) {
			
					// Steps 1-2.
					if (this == null) {
						throw new TypeError('this is null or not defined');
					}
				
					let O = Object(this);
				
					// Steps 3-5.
					let len = O.length >>> 0;
				
					// Steps 6-7.
					let start = arguments[1];
					let relativeStart = start >> 0;
				
					// Step 8.
					let k = relativeStart < 0 ?
						Math.max(len + relativeStart, 0) :
						Math.min(relativeStart, len);
				
					// Steps 9-10.
					let end = arguments[2];
					let relativeEnd = end === undefined ?
						len : end >> 0;
				
					// Step 11.
					let final = relativeEnd < 0 ?
						Math.max(len + relativeEnd, 0) :
						Math.min(relativeEnd, len);
				
					// Step 12.
					while (k < final) {
						O[k] = value;
						k++;
					}
				
					// Step 13.
					return O;
				}
			});
		}


		const connectSocket = () => {
			socket = io.connect();
			socket.on('connect', () => {
				console.log('connecting to server');
				socket.emit('join', {});
			});
			
			socket.on('disconnect', () => {
				console.log('disconnected from server');
			});
			
			socket.on('setUp', (data) => {
				// Import the entire sandArray (specifically for first entering the room)
				clientSandArray = data.value;

				sandArrayX = clientSandArray.length;
				sandArrayY = clientSandArray[0].length;

				suggestedPixelSize = data.suggestedPixelSize;
				if(suggestedPixelSize){
					pixelSize = suggestedPixelSize;
				}

				pixelWidth = sandArrayX * pixelSize;
				pixelHeight = sandArrayY * pixelSize;

				// Set the canvas size to match sandArray
				canvas.width = (clientSandArray.length * pixelSize);
				canvas.height = (clientSandArray[0].length * pixelSize);

				fullDraw();
			});


			socket.on('fullUpdate', (data) => {
				// Import the entire sandArray
				clientSandArray = data;
				
				// Redraw the updated scene
				fullDraw();
			});


			// Change the scene to the preset ordered by the server
			socket.on('changeScene', (data) => {
				// Clear the incoming Tiles Dictionary
				incomingTilesDict = {};
				
				// clear the scoreboard
				// Clear scene
				document.getElementById('clearCount').innerHTML = 0;
				document.getElementById('clearProgress').value = 0;
				// Lake floor scene
				document.getElementById('lakeFloorCount').innerHTML = 0;
				document.getElementById('lakeFloorProgress').value = 0;
				// Water Scene
				document.getElementById('waterCount').innerHTML = 0;
				document.getElementById('waterProgress').value = 0;
				// Random Scene
				document.getElementById('randomCount').innerHTML = 0;
				document.getElementById('randomProgress').value = 0;
				
				switch(data) {
				// Clear scene
				case 1:
					for (let i = 0; i < clientSandArray.length; i++) {
						clientSandArray[i] = new Array(clientSandArray[0].length);
						clientSandArray[i].fill(enumSandType.air);
					}
					break;
				// Sea floor scene
				case 2:
					let sandArrayX = clientSandArray.length;
					let sandArrayY = clientSandArray[0].length;
					
					// Check if the dimensions are big enough to work
					if((sandArrayY > 7) && (sandArrayX > 2)){
						// Calculate where the sand water border should be
						let borderRow = Math.floor((sandArrayY / 8) * 7);
						// Calculate plant offset
						let leftPlant = Math.floor(sandArrayX / 3);
						let rightPlant = (sandArrayX - leftPlant);
						// Preserve symmetry by adjusting for 0 index
						leftPlant = (leftPlant - 1);
						
						// make a template for a slice of the scene
						let templateArray  = new Array(clientSandArray[0].length);
						// Fill it with water
						templateArray.fill(enumSandType.water);
						// Fill the end with sand
						for (let i = borderRow; i < templateArray.length; i++) {
							templateArray[i] = enumSandType.sand;
						}
						
						// copy the template to every sub array
						for (let i = 0; i < clientSandArray.length; i++) {
							clientSandArray[i] = templateArray.slice();
						}
						
						
						// Insert the plant cells in the top sand layer
						clientSandArray[leftPlant][borderRow] = enumSandType.seaweed;
						clientSandArray[rightPlant][borderRow] = enumSandType.seaweed;
					}
					// Fall back to pure water
					else{
						for (let i = 0; i < clientSandArray.length; i++) {
							clientSandArray[i] = new Array(clientSandArray[0].length);
							clientSandArray[i].fill(enumSandType.water);
						}
					}
					break;
				// water scene
				case 3:
					for (let i = 0; i < clientSandArray.length; i++) {
						clientSandArray[i] = new Array(clientSandArray[0].length);
						clientSandArray[i].fill(enumSandType.water);
					}
					break;
				// random scene
				case 4:
					// Request a full scene update from the server
					socket.emit('fullUpdateRequest', {});
					break;
				default:
					console.log("Error: unrecognized scene type: " + data);
					break;
				}

				fullDraw();
			});
			
			// Update the vote count
			socket.on('sceneVote', (data) => {
				// Fill in the scoreboard
				// Clear scene
				document.getElementById('clearCount').innerHTML = data.clr;
				document.getElementById('clearProgress').value = data.clr;
				// Lake floor scene
				document.getElementById('lakeFloorCount').innerHTML = data.sea;
				document.getElementById('lakeFloorProgress').value = data.sea;
				// Water Scene
				document.getElementById('waterCount').innerHTML = data.h2o;
				document.getElementById('waterProgress').value = data.h2o;
				// Random Scene
				document.getElementById('randomCount').innerHTML = data.ran;
				document.getElementById('randomProgress').value = data.ran;
			});
			
			// Update the player count
			socket.on('playerCount', (data) => {
				// update the total player count UI
				document.getElementById('playerCount').innerHTML = data;

				// Calculate the first integer above 50% of total player count
				// First Past the Post Vote Total
				let fppVoteTotal = Math.floor((data / 2) + 1);

				// update the max value for each progress bar
				document.getElementById('clearProgress').max = fppVoteTotal;
				document.getElementById('lakeFloorProgress').max = fppVoteTotal;
				document.getElementById('waterProgress').max = fppVoteTotal;
				document.getElementById('randomProgress').max = fppVoteTotal;
			});
			
			// Handle sandArray updates
			socket.on('arrayUpdates', (data) => {
			
				// Add tiles to the incoming buffer
				Object.assign(incomingTilesDict, data);
			});
		};
		
		// Push all local change requests to the server
		const sendTilesToServer = () => {
			if(Object.keys(outGoingTilesDict).length > 0){
				socket.emit('arrayUpdateToServer', outGoingTilesDict);

				outGoingTilesDict = {};
			}
		}
		
		setInterval(() => {
			sendTilesToServer();
		}, 70);
		
		// Returns true if coordinates are in bounds
		const inBounds = (x,y) => {
			return(((x >= 0) && (x < sandArrayX)) && ((y >= 0) && (y < sandArrayY)));
		}
		
		// calculate a line between two mouse points and add them to the buffer with the current draw color
		const lineCalculator = (x0, y0, x1, y1) => {
			// if none of the values are null
			if((x0 !== null) && (y0 !== null) && (x1 !== null) && (y1 !== null)){
				let deltaX = x1 - x0;
				let deltaY = y1 - y0;

				// filter out zero vectors
				if(deltaX || deltaY){

					// quadrants 1 and 3
					if (Math.abs(deltaX) > Math.abs(deltaY)){

						let deltaError = Math.abs(deltaY / deltaX);
						let error = 0;
						let y = y0;

						// quadrant 1
						if(x1 > x0){

							for(let x = x0; x <= x1; x++){
								// Place the current pixel in the buffer
								tileProccess(x, y, drawColor);

								error = (error + deltaError);
								while(error >= 0.5){
									y = y + Math.sign(deltaY) * 1
									error = error - 1;
								}
							}
						}
						// quadrant 3
						else{

							for(let x = x0; x >= x1; x--){
								// Place the current pixel in the buffer
								tileProccess(x, y, drawColor);

								error = (error + deltaError);
								while(error >= 0.5){
									y = y + Math.sign(deltaY) * 1
									error = error - 1;
								}
							}
						}
					}
					// quadrants 2 and 4
					else{

						let deltaError = Math.abs(deltaX / deltaY);
						let error = 0;
						let x = x0;

						// quadrant 4
						if(y1 > y0){

							for(let y = y0; y <= y1; y++){
								// Place the current pixel in the buffer
								tileProccess(x, y, drawColor);

								error = (error + deltaError);
								while(error >= 0.5){
									x = x + Math.sign(deltaX) * 1
									error = error - 1;
								}
							}
						}
						// quadrant 2
						else{

							for(let y = y0; y >= y1; y--){
								// Place the current pixel in the buffer
								tileProccess(x, y, drawColor);

								error = (error + deltaError);
								while(error >= 0.5){
									x = x + Math.sign(deltaX) * 1
									error = error - 1;
								}
							}
						}
					}
				}
			}
		};
		
		// Identifies the tile and changes the draw color to its setting
		const drawColorSwitcher = (tile) => {
			switch(tile){
				// Air, Void, Eraser
				case 1:
					ctx.fillStyle = "#000000";
				break;
				
				// Sand
				case 2:
					ctx.fillStyle = "#ebefa0";
				break;
				
				// Water
				case 3:
					ctx.fillStyle = "#0000ff";
				break;
				
				// Salt
				case 4:
					ctx.fillStyle = "#ffffff";
				break;
				
				// Stone
				case 5:
					ctx.fillStyle = "#888888";
				break;
				
				// Salt Water
				case 6:
					ctx.fillStyle = "#aaccff";
				break;
				
				// Seaweed
				case 7:
					ctx.fillStyle = "#00ff00";
				break;
				
				default:
					// show error tiles in red
					ctx.fillStyle = "#ff0000";
			}
		}
		
		const fullDraw = () => {
			ctx.save();
			ctx.fillStyle = "#aa00ff";
			ctx.fillRect(0,0,canvas.width,canvas.height);
			ctx.translate(clientXTranslate,clientYTranslate);
			ctx.scale(clientScale, clientScale);
			
			// fill canvas with the current array values
			for (let lx = 0; lx < clientSandArray.length; lx++){
				for (let ly = 0; ly < clientSandArray[0].length; ly++){

					drawColorSwitcher(clientSandArray[lx][ly]);

					ctx.fillRect(lx * pixelSize, ly * pixelSize, pixelSize, pixelSize);
				}
			}

			// Draw scene centered circle
			/*ctx.beginPath();
			ctx.fillStyle = "#ff0000";
			ctx.arc((canvas.width / 2),(canvas.height / 2),20,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();*/
			
			ctx.restore();
			
			// Draw view centered circle
			/*ctx.beginPath();
			ctx.fillStyle = "#00ffff";
			ctx.arc((canvas.width / 2),(canvas.height / 2),15,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();*/
		};

		// Redraws only the tiles that need updating
		const partialDraw = () => {
			ctx.save();
			ctx.translate(clientXTranslate,clientYTranslate);
			ctx.scale(clientScale, clientScale);

			if(Object.keys(incomingTilesDict).length > 0){
				let changeListKeys = Object.keys(incomingTilesDict);

				// place each change in the local copy
				for (let i = 0; i < changeListKeys.length; i++){

					const tile = incomingTilesDict[changeListKeys[i]];
	
					// Assign the tile to the spot given by the server.
					clientSandArray[tile.x][tile.y] = tile.type;

					drawColorSwitcher(tile.type);

					ctx.fillRect(tile.x * pixelSize, tile.y * pixelSize, pixelSize, pixelSize);
				}

				// Force a draw over the entire scene to clear up artifacts
				// in isolated browser/GPU combinations
				// note: This is done by drawing pixels of the occupying tile types color
				// in either corner because IE wont support full screen clear rect overlays
				drawColorSwitcher(clientSandArray[0][0]);
				ctx.fillRect(0, 0, 0.5, 0.5);
				drawColorSwitcher(clientSandArray[clientSandArray.length - 1][clientSandArray[0].length - 1]);
				ctx.fillRect(pixelWidth-0.5, pixelHeight-0.5, 0.5, 0.5);

				// Clear the incoming tile buffer
				incomingTilesDict = {};
			}

			// Draw scene centered circle
			/*ctx.beginPath();
			ctx.fillStyle = "#ff0000";
			ctx.arc((canvas.width / 2),(canvas.height / 2),20,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();*/
			
			ctx.restore();
			
			// Draw view centered circle
			/*ctx.beginPath();
			ctx.fillStyle = "#00ffff";
			ctx.arc((canvas.width / 2),(canvas.height / 2),15,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();*/
			
			requestAnimationFrame(partialDraw);
		};
		
		// Returns the X position of the mouse/touch at time of request
		const getPositionX = (event) => {
			let coordinateX = 0;

			switch(event.type){
				case "mousemove":
				case "mousedown":
				case "mouseout":
				case "mouseover":
				case "wheel":
					coordinateX = event.pageX;
				break;
				case "touchmove":
				case "touchstart":
					coordinateX = event.touches[0].pageX;
				break;
				default:
					console.log("Warning: Unrecognized event type");
					coordinateX = 200;
			}

			return coordinateX - boundingClient.left;
		}

		// Returns the Y position of the mouse/touch at time of request
		const getPositionY = (event) => {
			let coordinateY;

			switch(event.type){
				case "mousemove":
				case "mousedown":
				case "mouseout":
				case "mouseover":
				case "wheel":
					coordinateY = event.pageY;
				break;
				case "touchmove":
				case "touchstart":
					coordinateY = event.touches[0].pageY;
				break;
				default:
					console.log("Warning: Unrecognized event type");
					coordinateY = 200;
			}

			return coordinateY - boundingClient.top;
		}


		// Translate the x coordinate to tile coordinates adjusted to the current transform
		const getTilePositionX = (event) => {
			return Math.floor((((getPositionX(event) / pixelWidth) * sandArrayX) * inverseClientScale) - (clientXTranslate / pixelSize) / clientScale);
		}


		// Translate the y coordinate to tile coordinates adjusted to the current transform
		const getTilePositionY = (event) => {
			return Math.floor((((getPositionY(event) / pixelHeight) * sandArrayY) * inverseClientScale) - (clientYTranslate / pixelSize) / clientScale);
		}


		const moveDrawing = (event) => {
			if(drawing){
				event.preventDefault();

				// Calculate the mouse position
				let positionX = getTilePositionX(event);
                let positionY = getTilePositionY(event);

				// draw a line between the mouse points
				lineCalculator(lastPosition.x, lastPosition.y, positionX, positionY);

				// Set this point as the starting point for the next line segment
				lastPosition = {x: positionX, y: positionY};
			}
			else if(moving){
				// Calculate the mouse position
				let positionX = (getPositionX(event) * inverseClientScale) - (clientXTranslate / pixelSize) / clientScale;
				let positionY = (getPositionY(event) * inverseClientScale) - (clientYTranslate / pixelSize) / clientScale;
				
				// Add the amount moved to the translation value
				translateProccessX(positionX - lastMovePosition.x);
				translateProccessY(positionY - lastMovePosition.y);
				
				fullDraw();

				// Set this point as the starting point for the next line segment
				lastMovePosition = {x: positionX, y: positionY};
			}
		};


		// Set X translation
		const translateProccessX = (xShift) => {
			// Update the unscaled translate
			unScaledclientXTranslate += xShift;

			// Prevent movement off the left edge
			if(unScaledclientXTranslate > 0){
				unScaledclientXTranslate = 0;
			}
			// Don't bother checking the other wall if it's up against this one
			else{
				// Calculate the furthest the scene can be translated left (how far right the viewport can appear to move)
				let furthestAllowedValue = -(pixelWidth - (canvas.width / clientScale));

				// Prevent movement off the right edge
				if(unScaledclientXTranslate < furthestAllowedValue){
					unScaledclientXTranslate = furthestAllowedValue;
				}
			}

			// Update the scaled translate
			clientXTranslate = (unScaledclientXTranslate * clientScale);
		}


		// Set Y translation
		const translateProccessY = (yShift) => {
			// Update the unscaled translate
			unScaledclientYTranslate += yShift;

			// Prevent movement off the top edge
			if(unScaledclientYTranslate > 0){
				unScaledclientYTranslate = 0;
			}
			// Dont bother checking the other wall if it's up against this one
			else{
				// Calculate the furthest the scene can be translated up (how far down the viewport can appear to move)
				let furthestAllowedValue = -(pixelHeight - (canvas.height / clientScale));

				// Prevent movement off the bottom edge
				if(unScaledclientYTranslate < furthestAllowedValue){
					unScaledclientYTranslate = furthestAllowedValue;
				}
			}

			// Update the scaled translate
			clientYTranslate = (unScaledclientYTranslate * clientScale);
		}
		
		
		// Add value to scale, prevent cap overflow, and update the inverseClientScale
		const scaleProccess = (scale) => {
			clientScale += scale;
			
			// cap the wide zoom at the scene size
			if (clientScale < 1){
				clientScale = 1;
			}
			
			// cap the narrow zoom at a reasonable size size
			if (clientScale > 45){
				clientScale = 45;
			}
			
			// Update the inverseClientScale
			inverseClientScale = (1 / clientScale);
		}
		
		
		// If an action turns out to be non-drawing, call this method to cancel and clear the buffer
		const stifleDelayedDrawing = () => {
			delayDrawing = false;
			tempTilesDict =  {};
		}


		// Check that the tile should be sent
		const tileProccess = (x, y, tileType) => {
			// Add the tile to the list to be sent to the server,
			if(inBounds(x,y)){
				// Note for future development, place code here to avoid sending a tile if that tile already
				// exists in this spot but only if there arent tiles around that are likey to replace it.
				// without that extra step, it becomes noticably harder to draw over moving tiles.
				// Proposal: make a continuously updated array that lets the tiles check if they are bordered
				// by any tiles that are not the same as them.
				
				if(!delayDrawing){
					// Place the current pixel in the buffer
					outGoingTilesDict[`${x},${y}`] = {x: x, y: y, type: tileType};
				}
				else{
					tempTilesDict[`${x},${y}`] = {x: x, y: y, type: tileType};
					
					// If more then given time has passed
					if((Date.now() - delayDrawing) > tempTime){

						delayDrawing = false;
						
						transferTempBuffer();
					}
				}
			}
		}

		
		// move tiles from tempTilesDict to outGoingTilesDict
		const transferTempBuffer = () => {
			// Move all tiles to the outGoingTilesDict
			if(Object.keys(tempTilesDict).length > 0){

				let changeListKeys = Object.keys(tempTilesDict);

				for (let i = 0; i < changeListKeys.length; i++){

					const tile = tempTilesDict[changeListKeys[i]];

					outGoingTilesDict[changeListKeys[i]] = tempTilesDict[changeListKeys[i]];
				}

				// Reset tempTilesDict
				tempTilesDict =  {};
			}
		}

		// Draw particles at the last recorded position so static cursors still emit particles
		// Note: At slow draw speeds,the positions wont change fast enough to detect movement
		// between checks, the effect is redundant writing to the scene, this
		// has minimal overhead for now and does not change functionality.
		const drawIdle = () => {
			// If the drawing action is still taking place
			if(drawing || touchDrawing){
				// If a lastPosition and lastIdlePosition Exists
				if((lastPosition.x !== null) && (lastPosition.y !== null) && (lastIdlePosition.x !== null) && (lastIdlePosition.y !== null)){
					// If the cursor hasn't moved since the last idle draw
					if((lastIdlePosition.x === lastPosition.x) && (lastIdlePosition.y === lastPosition.y)){
						tileProccess(lastPosition.x, lastPosition.y, drawColor)
					}
				}

				// Remember this as the last point drawn from
				lastIdlePosition = {x: lastPosition.x, y: lastPosition.y};

				// Since drawing is still active, renew the cycle.
				requestAnimationFrame(drawIdle);
			}
		}


		const activateDrawing = (event) => {

			// Calculate the mouse position
			let positionX = getTilePositionX(event);
            let positionY = getTilePositionY(event);

			// React to left click
            if(event.button === 0){
			  event.preventDefault();
			  drawing = true;

			  // Jump start drawIdle
			  drawIdle();

			  // Place the current pixel in the buffer
			  tileProccess(positionX, positionY, drawColor);

			  // Set this point as the starting point for the line.
			  lastPosition = {x: positionX, y: positionY};
			}
			// React to middle button click
			if(event.button === 1){
				event.preventDefault();
				// Set drawColor to the sand value of the currently selected tile
				drawColor = clientSandArray[positionX][positionY];
				// Update the selector value to reflect the current sand type
				document.querySelector("#sandType").value = drawColor;
			}
			// React to right button click
			if(event.button === 2){
				event.preventDefault();
				moving = true;

				let positionX = getPositionX(event);
				let positionY = getPositionY(event);

				positionX = (positionX * inverseClientScale) - (clientXTranslate / pixelSize) / clientScale;
				positionY = (positionY * inverseClientScale) - (clientYTranslate / pixelSize) / clientScale;
				lastMovePosition = {x: positionX, y: positionY};
				//lastMovePosition = {x: null, y: null};
			}
		};
		
		const activateTouchDrawing = (event) => {
			event.preventDefault();
			
			let positionX = getTilePositionX(event);
			let positionY = getTilePositionY(event);

			touchDrawing = true;
			delayDrawing = Date.now();

			// Jump start drawIdle
			drawIdle();
			
			// Place the current pixel in the buffer
			tileProccess(positionX, positionY, drawColor);
			
			// Set this point as the starting point for the line.
			lastPosition = {x: positionX, y: positionY};
		};
		
		const moveTouchDrawing = (event) => {
			event.preventDefault();
			
			switch(event.touches.length){
				case 1:
					let positionX = getTilePositionX(event);
					let positionY = getTilePositionY(event);
		
					// draw a line between the mouse points
					lineCalculator(lastPosition.x, lastPosition.y, positionX, positionY);
						
					// Set this point as the starting point for the line.
					lastPosition = {x: positionX, y: positionY};
				break;
				case 2:
					// Deactivate touchDrawing to stop idleDraw
					touchDrawing = false;
					
					// Clear the built up tiles and reset the delay counter
					stifleDelayedDrawing();

					// Calculate the line between the two fingers
					let vector = {x: ((event.touches[1].pageX - boundingClient.left) - (event.touches[0].pageX - boundingClient.left)),y: ((event.touches[1].pageY - boundingClient.top) - (event.touches[0].pageY - boundingClient.top))};

					// Calculate the distance between the fingers
					vector.magnitude = Math.sqrt(Math.abs((vector.x)^2)+Math.abs((vector.y)^2));

					// Calculate the global coordinates of the point in the center of the line between the two fingers
					let centerPt = {x:null, y: null};
					centerPt.x = (event.touches[0].pageX + (vector.x / 2));
					centerPt.y = (event.touches[0].pageY + (vector.y / 2));
					
					// If this code has been passed through once before this event and lastPinchData is not null
					if(lastPinchData.magnitude !== null){
						
						let previousScale = clientScale;
						
						// Scale the scene in ratio to the pinch action
						scaleProccess(((vector.magnitude - lastPinchData.magnitude) * clientScale) / 10);
						
						// Calculate the differences in center point positions and move that much weighted to the zoom scale
						let posX = (centerPt.x - lastPinchData.centerPt.x) * inverseClientScale;
						let posY = (centerPt.y - lastPinchData.centerPt.y) * inverseClientScale;
						
						// zoom from center point and add the panning movement before translating
						translateProccessX(posX -((centerPt.x * inverseClientScale) / (previousScale / (clientScale - previousScale))));
						translateProccessY(posY -((centerPt.y * inverseClientScale) / (previousScale / (clientScale - previousScale))));
						
						fullDraw();
					}
					
					// Store the data to compare later
					lastPinchData = {magnitude: vector.magnitude, centerPt: centerPt};
				break;
			}
		};
		
		const deactivateDrawing = (event) => {
			event.preventDefault();
			drawing = false;
			moving = false;
			touchDrawing = false;
			
			// If the time is under the tempTime range and the touch ended without
			// being deactivated by the move case, its probably a quick tap and should
			// be interpreted as a single pixel draw.
			if(delayDrawing){
				if((Date.now() - delayDrawing) < tempTime){
					transferTempBuffer();
				}
			}
			else{
				// Clear the built up tiles and reset the delay counter
				stifleDelayedDrawing();
			}

			// These data structures use null values to signify the first recorded position in the motion.
			// Reset them to prevent old data messing with the new action.
			lastPosition = {x: null, y: null};
			lastPinchData = {magnitude: null, centerPt: null};
		};
		
		const edgeInDrawing = (event) => {
			if(drawing){
				event.preventDefault();
				// Calculate the mouse position
				let positionX = getTilePositionX(event);
				let positionY = getTilePositionY(event);
			
				// Set this point as the starting point for the line.
				lastPosition = {x: positionX, y: positionY};
			}
		};
		
		const edgeOutDrawing = (event) => {
			if(drawing){
				event.preventDefault();
				// Calculate the mouse position
				let positionX = getTilePositionX(event);
				let positionY = getTilePositionY(event);
			
				// draw a line between the mouse points
				lineCalculator(lastPosition.x, lastPosition.y, positionX, positionY);
			}
		};
		
		// Send the server the clients vote choice
		const stageChangeRequestCall = (event) => {
			// Send the request to clear the scene
			socket.emit('stageChangeRequest', parseInt(document.querySelector("#voteChoice").value));
		};
		
		// Request a redraw when focus is returned to the window
		const focusRedraw = () => {
			// Send the request to clear the scene
			socket.emit('fullUpdateRequest', {});
		};
		
		// React to scrolling action to scale the scene
		const wheel = (event) => {
			event.preventDefault();
			
			// Calculate the mouse position
			let positionX = getPositionX(event);
            let positionY = getPositionY(event);
			
			// Translations for the new center must be done in the context of the old scale window
			// so save the previous scale for later use
			let previousScale = clientScale;

			// Mouse wheel motions are too imprecise to use so all scroll actions are flattened to 1 in either direction
			if(event.deltaY < 0){
				
				// Scale the scene at a visually linear rate
				scaleProccess((zoomValue * clientScale) / 10);

				if(previousScale !== clientScale){

					// Move to maintain center point after scale
					translateProccessX(-((positionX * inverseClientScale) / (previousScale / (clientScale - previousScale))));
					translateProccessY(-((positionY * inverseClientScale) / (previousScale / (clientScale - previousScale))));
				}
			}
			else{

				// Scale the scene at a visually linear rate
				scaleProccess(-((zoomValue * clientScale) / 10));

				if(previousScale !== clientScale){

					// Zoom out from mouse position
					translateProccessX(((positionX) * inverseClientScale) / (previousScale / (previousScale - clientScale)));
					translateProccessY(((positionY) * inverseClientScale) / (previousScale / (previousScale - clientScale)));
				}
			}

			// Redraw the scene with the new transform
			fullDraw();
		};
		
		const init = () => {
			// Prevent default right click behavior
			canvas.oncontextmenu = function() {
				return false;
			}

			// define event for FireFox
			if (!event) {
				var event = window.Event;
			};

			connectSocket();
			canvas.onmousemove = moveDrawing.bind(event);
			canvas.ontouchmove = moveTouchDrawing.bind(event);
			canvas.onmousedown = activateDrawing.bind(event);
			window.onmouseup = deactivateDrawing.bind(event);
			canvas.ontouchstart = activateTouchDrawing.bind(event);
			canvas.ontouchend = deactivateDrawing.bind(event);
			canvas.onmouseout = edgeOutDrawing.bind(event);
			canvas.onmouseover = edgeInDrawing.bind(event);
			window.onfocus = focusRedraw.bind();
			canvas.onwheel = wheel.bind(event);
			
			document.querySelector("#sandType").onchange = function(e){

				drawColor = parseInt(e.target.value);
			}
			
			const stageChangeRequest = document.querySelector("#voteScene");
			stageChangeRequest.addEventListener('click', stageChangeRequestCall);
			
			requestAnimationFrame(partialDraw);
		};
		
		// Add init to the functions to run with the onload event
		// credit for load code:
		// https://ckon.wordpress.com/2008/07/25/stop-using-windowonload-in-javascript/
		window.addEventListener ? 
		window.addEventListener("load",init,false) : 
		window.attachEvent && window.attachEvent("onload",init);
    </script>
</head>
<body>
	<canvas id="canvas">
		Your browser does not support the HTML5 canvas tag.
	</canvas>
	<div id="controls">
		<label>Sand Types
			<select id="sandType">
				<option value="4">Salt</option>
				<option value="6">Salt Water</option>
				<option value="2" selected>Sand</option>
				<option value="7">Seaweed</option>
				<option value="5">Stone</option>
				<option value="1">Air (Eraser)</option>
				<option value="3">Water</option>
			</select>
		</label>
		<div id="sceneVote">
			<div id="voteFiller">
				<label>Scenes Options
					<select id="voteChoice">
						<option value="0" selected>No Change</option>
						<option value="1">Clear</option>
						<option value="2">Lake floor</option>
						<option value="3">Water</option>
						<option value="4">Random Chaos</option>
					</select>
				</label>
				<input id="voteScene" type='button' value='Cast Vote'/>
			</div>
			<div id="voteResults">
				<div id="voteClear">
					<span>Clear Total: </span>
					<span id="clearCount"></span>
					<progress id="clearProgress" value="0" max="100"></progress>
				</div>
				<div id="voteLakeFloor">
					<span>Lake Floor Total: </span>
					<span id="lakeFloorCount"></span>
					<progress id="lakeFloorProgress" value="0" max="100"></progress>
				</div>
				<div id="voteWater">
					<span>Water Total: </span>
					<span id="waterCount"></span>
					<progress id="waterProgress" value="0" max="100"></progress>
				</div>
				<div id="voteRandom">
					<span>Random Chaos Total: </span>
					<span id="randomCount"></span>
					<progress id="randomProgress" value="0" max="100"></progress>
				</div>
			</div>
		</div>
		<div id="players">
			<span>Players Online: </span>
			<span id="playerCount"></span>
		<div>
	</div>
</body>
</html>
























