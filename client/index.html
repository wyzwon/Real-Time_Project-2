<!DOCTYPE html>
<html lang="en">
<head>
	<script src="/socket.io/socket.io.js"></script>
    <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
    <script type="text/babel">
        "use strict";
		
		let canvas = document.querySelector('canvas');
		let ctx = canvas.getContext('2d');
		
		var socket = {};

		let drawing = false;
		
		let pixelSize = 4;
		let suggestedPixelSize;

		let clientSandArray = [];
		let blankBufferArray = [];

		const connectSocket = () => {
			socket = io.connect();
			socket.on('connect', () => {
				console.log('connecting to server');
				socket.emit('join', {});
			});
			
			socket.on('disconnect', () => {
				console.log('disconnected from server');
			});

			socket.on('msg', (data) => {
				console.log(data);
				chat.value = `${data.value}`;
			});
			
			socket.on('setUp', (data) => {
				// Import the sandArray in full (specifically for first entering the room)
				clientSandArray = data.value;
				
				suggestedPixelSize = data.suggestedPixelSize;
				if(suggestedPixelSize){
					pixelSize = suggestedPixelSize;
				}
				
				blankBufferArray = clientSandArray.map(row => row.slice());
				for (let i = 0; i < blankBufferArray.length; i++) {
					blankBufferArray[i] = new Array(blankBufferArray[0].length);
					blankBufferArray[i].fill(1);
				}
				
				// Set the canvas size to match sandArray
				canvas.width = (clientSandArray.length * pixelSize);
				canvas.height = (clientSandArray[0].length * pixelSize);
				
				draw();
			});

			socket.on('fullArray', (data) => {
				// Import the sandArray in full (specifically for first entering the room)
				clientSandArray = data.value;
				
				// Set the canvas size to match sandArray
				canvas.width = (clientSandArray.length * pixelSize);
				canvas.height = (clientSandArray[0].length * pixelSize);
				
				draw();
			});
			
			// Clear the local scene when server clears the main scene
			socket.on('clearScene', (data) => {
				clientSandArray = blankBufferArray.map(row => row.slice());
			});
			
			// handle sandArray updates
			socket.on('arrayUpdates', (data) => {

				let changeListKeys = Object.keys(data);

				// place each change in the local copy
				for (let i = 0; i < changeListKeys.length; i++){

					const tile = data[changeListKeys[i]];

					// Assign the tile to the spot given by the server.
					clientSandArray[tile.x][tile.y] = tile.type;
				}

				draw(); // draw the updated scene
			});
		};
		
		const draw = () => {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			// fill canvas with the current array values
			for (let lx = 0; lx < clientSandArray.length; lx++){
				for (let ly = 0; ly < clientSandArray[0].length; ly++){
					
					if(clientSandArray[lx][ly] === 1){
						ctx.fillStyle = "#000000";
					}
					else if(clientSandArray[lx][ly] === 2){
						ctx.fillStyle = "#ff0000";
					}
					else if(clientSandArray[lx][ly] === 3){
						ctx.fillStyle = "#00ff00";
					}
					else if(clientSandArray[lx][ly] === 4){
						ctx.fillStyle = "#0000ff";
					}
					/*else{
						console.log("Unrecognized type");
						console.log(clientSandArray[lx][ly]);
					}*/
					
					ctx.fillRect(lx * pixelSize, ly * pixelSize, pixelSize, pixelSize);
					
				}
			}
		};
		
		const setCalls = (event) => {
			if(drawing)
			{
				const boundingClient = canvas.getBoundingClientRect();
				let x = event.clientX - boundingClient.left;
				let y = event.clientY - boundingClient.top;

				x = Math.floor((x / canvas.width) * clientSandArray.length);
				y = Math.floor((y / canvas.height) * clientSandArray[0].length);

				const tilesArray = {};
				tilesArray[0] = {x: x, y: y, type: 2};
				
				socket.emit('arrayUpdateToServer', tilesArray);
				
				draw();
			}
		};
		
		const activateDrawing = (event) => {
			drawing = true;
			//console.log("draw activated");
		};
		
		const deactivateDrawing = (event) => {
			drawing = false;
			//console.log("draw deactivated");
		};
		
		const clearRequestCall = (e) => {
			// Send the request to clear the scene
			socket.emit('clearRequest', {});
		};
		
		const init = () => {
			connectSocket();
			//canvas.onmousedown = setCalls.bind(event);
			canvas.onmousemove = setCalls.bind(event);
			canvas.ontouchmove = setCalls.bind(event);
			canvas.onmousedown = activateDrawing.bind(event);
			canvas.onmouseup = deactivateDrawing.bind(event);
			canvas.ontouchstart = activateDrawing.bind(event);
			canvas.ontouchend = deactivateDrawing.bind(event);
			
			const clearRequest = document.querySelector("#clear");
			clearRequest.addEventListener('click', clearRequestCall);
		};
		
		window.onload = init;
    </script>
</head>
<body>
	<canvas id="canvas" width="400" height="400" style="border:1px solid #555555; touch-action: none;">
		Your browser does not support the HTML5 canvas tag.
	</canvas>
	<input id="clear" type='button' value='clear'/>
</body>
</html>
























