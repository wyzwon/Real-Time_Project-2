<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=Edge"/>
	<meta name="description" content="Multi-player particle simulator"> 
	
	<title>Particle Sim</title>

	<Link rel="stylesheet" type="text/css" href="styleSheets/style.css"/>

	<Link rel="apple-touch-icon-precomposed" sizes="256x256" href="assets/particleSimLogo.png"/>
	<Link rel="shortcut icon" type="image/ico" href="favicon.ico"/>
	<Link rel="icon" type="image/ico" href="favicon.ico"/>

	<script src="/socket.io/socket.io.js"></script>
    <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
    <script type="text/babel">
        "use strict";
		
		let canvas = document.querySelector('canvas');
		let ctx = canvas.getContext('2d');
		
		var socket = {};

		// Flag for draw action underway
		let drawing = false;

		// Flag for move action underway
		let moving = false;
		
		let pixelSize = 4;
		let suggestedPixelSize;

		let clientSandArray = [];

		let outGoingTilesDict = {};
		let incomingTilesDict = {};
		
		let clientScale = 1;
		let inverseClientScale = 1;
		
		// Scaled translate values
		let clientXTranslate = 0;
		let clientYTranslate = 0;
		
		// Unscaled translate values
		let unScaledclientXTranslate = 0;
		let unScaledclientYTranslate = 0;
		
		// Note: air = void = eraser
		const enumSandType = Object.freeze({
			air: 1,
			sand: 2,
			water: 3,
			salt: 4,
			stone: 5,
			saltWater: 6,
			seaweed: 7,
		});
		
		// Client copy of the scene lengths
		let sandArrayX = 0;
		let sandArrayY = 0;
		
		// value of change in zoom
		let zoomValue = 1;
			
		// Currently selected particle type
		let drawColor = parseInt(document.querySelector("#sandType").value);
		
		// Last position the mouse was located while drawing
		let lastPosition = {};
		let lastMovePosition = {};
		const boundingClient = canvas.getBoundingClientRect();
		
		// Math.sign is unsupported in IE so a custom version must be inserted
		// credit for sign code:
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
		if(!Math.sign){
			Math.sign = function(x){return typeof x === 'number' ? x ? x < 0 ? -1 : 1 : x === x ? 0 : NaN : NaN;};
		}
		
		// Object.assign is unsupported in IE so a custom version must be inserted
		// credit for assign code:
		// https://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically
		if(!Object.assign){
			Object.assign = function(obj1, obj2){for (let attrname in obj2) { obj1[attrname] = obj2[attrname]; }};
		}
		
		// Array.fill is unsupported in IE so a custom version must be inserted
		// credit for fill code (modified for ECMAScript 6):
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
		if (!Array.prototype.fill) {
			Object.defineProperty(Array.prototype, 'fill', {
				value: function(value) {
			
					// Steps 1-2.
					if (this == null) {
						throw new TypeError('this is null or not defined');
					}
				
					let O = Object(this);
				
					// Steps 3-5.
					let len = O.length >>> 0;
				
					// Steps 6-7.
					let start = arguments[1];
					let relativeStart = start >> 0;
				
					// Step 8.
					let k = relativeStart < 0 ?
						Math.max(len + relativeStart, 0) :
						Math.min(relativeStart, len);
				
					// Steps 9-10.
					let end = arguments[2];
					let relativeEnd = end === undefined ?
						len : end >> 0;
				
					// Step 11.
					let final = relativeEnd < 0 ?
						Math.max(len + relativeEnd, 0) :
						Math.min(relativeEnd, len);
				
					// Step 12.
					while (k < final) {
						O[k] = value;
						k++;
					}
				
					// Step 13.
					return O;
				}
			});
		}


		const connectSocket = () => {
			socket = io.connect();
			socket.on('connect', () => {
				console.log('connecting to server');
				socket.emit('join', {});
			});
			
			socket.on('disconnect', () => {
				console.log('disconnected from server');
			});
			
			socket.on('setUp', (data) => {
				// Import the entire sandArray (specifically for first entering the room)
				clientSandArray = data.value;
				
				sandArrayX = clientSandArray.length;
				sandArrayY = clientSandArray[0].length;
				
				suggestedPixelSize = data.suggestedPixelSize;
				if(suggestedPixelSize){
					pixelSize = suggestedPixelSize;
				}
				
				// Set the canvas size to match sandArray
				canvas.width = (clientSandArray.length * pixelSize);
				canvas.height = (clientSandArray[0].length * pixelSize);

				fullDraw();
			});


			socket.on('fullUpdate', (data) => {
				// Import the entire sandArray
				clientSandArray = data;
				
				// Redraw the updated scene
				fullDraw();
			});


			// Change the scene to the preset ordered by the server
			socket.on('changeScene', (data) => {
				// Clear the incoming Tiles Dictionary
				incomingTilesDict = {};
				
				// clear the scoreboard
				// Clear scene
				document.getElementById('clearCount').innerHTML = 0;
				document.getElementById('clearProgress').value = 0;
				// Lake floor scene
				document.getElementById('lakeFloorCount').innerHTML = 0;
				document.getElementById('lakeFloorProgress').value = 0;
				// Water Scene
				document.getElementById('waterCount').innerHTML = 0;
				document.getElementById('waterProgress').value = 0;
				// Random Scene
				document.getElementById('randomCount').innerHTML = 0;
				document.getElementById('randomProgress').value = 0;
				
				switch (data) {
				// Clear scene
				case 1:
					for (let i = 0; i < clientSandArray.length; i++) {
						clientSandArray[i] = new Array(clientSandArray[0].length);
						clientSandArray[i].fill(enumSandType.air);
					}
					break;
				// Sea floor scene
				case 2:
					let sandArrayX = clientSandArray.length;
					let sandArrayY = clientSandArray[0].length;
					
					// Check if the dimensions are big enough to work
					if((sandArrayY > 7) && (sandArrayX > 2)){
						// Calculate where the sand water border should be
						let borderRow = Math.floor((sandArrayY / 8) * 7);
						// Calculate plant offset
						let leftPlant = Math.floor(sandArrayX / 3);
						let rightPlant = (sandArrayX - leftPlant);
						// Preserve symmetry by adjusting for 0 index
						leftPlant = (leftPlant - 1);
						
						// make a template for a slice of the scene
						let templateArray  = new Array(clientSandArray[0].length);
						// Fill it with water
						templateArray.fill(enumSandType.water);
						// Fill the end with sand
						for (let i = borderRow; i < templateArray.length; i++) {
							templateArray[i] = enumSandType.sand;
						}
						
						// copy the template to every sub array
						for (let i = 0; i < clientSandArray.length; i++) {
							clientSandArray[i] = templateArray.slice();
						}
						
						
						// Insert the plant cells in the top sand layer
						clientSandArray[leftPlant][borderRow] = enumSandType.seaweed;
						clientSandArray[rightPlant][borderRow] = enumSandType.seaweed;
					}
					// Fall back to pure water
					else{
						for (let i = 0; i < clientSandArray.length; i++) {
							clientSandArray[i] = new Array(clientSandArray[0].length);
							clientSandArray[i].fill(enumSandType.water);
						}
					}
					break;
				// water scene
				case 3:
					for (let i = 0; i < clientSandArray.length; i++) {
						clientSandArray[i] = new Array(clientSandArray[0].length);
						clientSandArray[i].fill(enumSandType.water);
					}
					break;
				// random scene
				case 4:
					// Request a full scene update from the server
					socket.emit('fullUpdateRequest', {});
					break;
				default:
					console.log("Error: unrecognized scene type: " + data);
					break;
				}

				fullDraw();
			});
			
			// Update the vote count
			socket.on('sceneVote', (data) => {
				// Fill in the scoreboard
				// Clear scene
				document.getElementById('clearCount').innerHTML = data.clr;
				document.getElementById('clearProgress').value = data.clr;
				// Lake floor scene
				document.getElementById('lakeFloorCount').innerHTML = data.sea;
				document.getElementById('lakeFloorProgress').value = data.sea;
				// Water Scene
				document.getElementById('waterCount').innerHTML = data.h2o;
				document.getElementById('waterProgress').value = data.h2o;
				// Random Scene
				document.getElementById('randomCount').innerHTML = data.ran;
				document.getElementById('randomProgress').value = data.ran;
			});
			
			// Update the player count
			socket.on('playerCount', (data) => {
				// update the total player count UI
				document.getElementById('playerCount').innerHTML = data;

				// Calculate the first integer above 50% of total player count
				// First Past the Post Vote Total
				let fppVoteTotal = Math.floor((data / 2) + 1);

				// update the max value for each progress bar
				document.getElementById('clearProgress').max = fppVoteTotal;
				document.getElementById('lakeFloorProgress').max = fppVoteTotal;
				document.getElementById('waterProgress').max = fppVoteTotal;
				document.getElementById('randomProgress').max = fppVoteTotal;
			});
			
			// Handle sandArray updates
			socket.on('arrayUpdates', (data) => {
			
				// Add tiles to the incoming buffer
				Object.assign(incomingTilesDict, data);
			});
		};
		
		// Push all local change requests to the server
		const sendTilesToServer = () => {
			if(Object.keys(outGoingTilesDict).length > 0){
				socket.emit('arrayUpdateToServer', outGoingTilesDict);

				outGoingTilesDict = {};
			}
		}
		
		setInterval(() => {
			sendTilesToServer();
		}, 70);
		
		// Returns true if coordinates are in bounds
		const inBounds = (x,y) => {
			return(((x >= 0) && (x < sandArrayX)) && ((y >= 0) && (y < sandArrayY)));
		}
		
		// calculate a line between two mouse points and add them to the buffer with the current draw color
		const lineCalculator = (x0, y0, x1, y1) => {
			let deltaX = x1 - x0;
			let deltaY = y1 - y0;
			
			// filter out zero vectors
			if(deltaX || deltaY){
				
				// quadrants 1 and 3
				if (Math.abs(deltaX) > Math.abs(deltaY)){
				
					let deltaError = Math.abs(deltaY / deltaX);
					let error = 0;
					let y = y0;
					
					// quadrant 1
					if(x1 > x0){

						for(let x = x0; x <= x1; x++){
							// Place the current pixel in the buffer
							tileProccess(x, y, drawColor);
							
							error = (error + deltaError);
							while(error >= 0.5){
								y = y + Math.sign(deltaY) * 1
								error = error - 1;
							}
						}
					}
					// quadrant 3
					else{
						
						for(let x = x0; x >= x1; x--){
							// Place the current pixel in the buffer
							tileProccess(x, y, drawColor);
							
							error = (error + deltaError);
							while(error >= 0.5){
								y = y + Math.sign(deltaY) * 1
								error = error - 1;
							}
						}
					}
				}
				// quadrants 2 and 4
				else{
				
					let deltaError = Math.abs(deltaX / deltaY);
					let error = 0;
					let x = x0;
					
					// quadrant 4
					if(y1 > y0){

						for(let y = y0; y <= y1; y++){
							// Place the current pixel in the buffer
							tileProccess(x, y, drawColor);
							
							error = (error + deltaError);
							while(error >= 0.5){
								x = x + Math.sign(deltaX) * 1
								error = error - 1;
							}
						}
					}
					// quadrant 2
					else{

						for(let y = y0; y >= y1; y--){
							// Place the current pixel in the buffer
							tileProccess(x, y, drawColor);
							
							error = (error + deltaError);
							while(error >= 0.5){
								x = x + Math.sign(deltaX) * 1
								error = error - 1;
							}
						}
					}
				}
			}
		};
		
		// Identifies the tile and changes the draw color to its setting
		const drawColorSwitcher = (tile) => {
			switch(tile){
				// Air, Void, Eraser
				case 1:
					ctx.fillStyle = "#000000";
				break;
				
				// Sand
				case 2:
					ctx.fillStyle = "#ebefa0";
				break;
				
				// Water
				case 3:
					ctx.fillStyle = "#0000ff";
				break;
				
				// Salt
				case 4:
					ctx.fillStyle = "#ffffff";
				break;
				
				// Stone
				case 5:
					ctx.fillStyle = "#888888";
				break;
				
				// Salt Water
				case 6:
					ctx.fillStyle = "#aaccff";
				break;
				
				// Seaweed
				case 7:
					ctx.fillStyle = "#00ff00";
				break;
				
				default:
					// show error tiles in red
					ctx.fillStyle = "#ff0000";
			}
		}
		
		const fullDraw = () => {
			ctx.save();
			ctx.fillStyle = "#aa00ff";
			ctx.fillRect(0,0,canvas.width,canvas.height);
			ctx.translate(clientXTranslate,clientYTranslate);
			ctx.scale(clientScale, clientScale);
			
			// fill canvas with the current array values
			for (let lx = 0; lx < clientSandArray.length; lx++){
				for (let ly = 0; ly < clientSandArray[0].length; ly++){

					drawColorSwitcher(clientSandArray[lx][ly]);

					ctx.fillRect(lx * pixelSize, ly * pixelSize, pixelSize, pixelSize);
				}
			}

			// Draw scene centered circle
			/*ctx.beginPath();
			ctx.fillStyle = "#ff0000";
			ctx.arc((canvas.width / 2),(canvas.height / 2),20,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();*/
			
			ctx.restore();
			
			// Draw view centered circle
			/*ctx.beginPath();
			ctx.fillStyle = "#00ffff";
			ctx.arc((canvas.width / 2),(canvas.height / 2),15,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();*/
		};

		// Redraws only the tiles that need updating
		const partialDraw = () => {
			ctx.save();
			ctx.translate(clientXTranslate,clientYTranslate);
			ctx.scale(clientScale, clientScale);

			if(Object.keys(incomingTilesDict).length > 0){
				let changeListKeys = Object.keys(incomingTilesDict);

				// place each change in the local copy
				for (let i = 0; i < changeListKeys.length; i++){

					const tile = incomingTilesDict[changeListKeys[i]];
	
					// Assign the tile to the spot given by the server.
					clientSandArray[tile.x][tile.y] = tile.type;

					drawColorSwitcher(tile.type);

					ctx.fillRect(tile.x * pixelSize, tile.y * pixelSize, pixelSize, pixelSize);
				}

				// Force a draw over the entire scene to clear up artifacts
				// in isolated browser/GPU combinations
				// note: This is done by drawing pixels of the occupying tile types color
				// in either corner because IE wont support full screen clear rect overlays
				drawColorSwitcher(clientSandArray[0][0]);
				ctx.fillRect(0, 0, 0.5, 0.5);
				drawColorSwitcher(clientSandArray[clientSandArray.length - 1][clientSandArray[0].length - 1]);
				ctx.fillRect(canvas.width-0.5, canvas.height-0.5, 0.5, 0.5);

				// Clear the incoming tile buffer
				incomingTilesDict = {};
			}

			// Draw scene centered circle
			/*ctx.beginPath();
			ctx.fillStyle = "#ff0000";
			ctx.arc((canvas.width / 2),(canvas.height / 2),20,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();*/
			
			ctx.restore();
			
			// Draw view centered circle
			/*ctx.beginPath();
			ctx.fillStyle = "#00ffff";
			ctx.arc((canvas.width / 2),(canvas.height / 2),15,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();*/
			
			requestAnimationFrame(partialDraw);
		};
		
		// Returns the X position of the mouse/touch at time of request
		const getPositionX = (event) => {
			let coordinateX = 0;

			switch(event.type){
				case "mousemove":
				case "mousedown":
				case "mouseout":
				case "mouseover":
				case "wheel":
					coordinateX = event.pageX;
				break;
				case "touchmove":
				case "touchstart":
					coordinateX = event.touches[0].pageX;
				break;
				default:
					console.log("Warning: Unrecognized event type");
					coordinateX = 200;
			}

			return coordinateX - boundingClient.left;
		}

		// Returns the Y position of the mouse/touch at time of request
		const getPositionY = (event) => {
			let coordinateY;

			switch(event.type){
				case "mousemove":
				case "mousedown":
				case "mouseout":
				case "mouseover":
				case "wheel":
					coordinateY = event.pageY;
				break;
				case "touchmove":
				case "touchstart":
					coordinateY = event.touches[0].pageY;
				break;
				default:
					console.log("Warning: Unrecognized event type");
					coordinateY = 200;
			}

			return coordinateY - boundingClient.top;
		}


		// Translate the x coordinate to tile coordinates adjusted to the current transform
		const getTilePositionX = (event) => {
			return Math.floor((((getPositionX(event) / canvas.width) * sandArrayX) * inverseClientScale) - (clientXTranslate / pixelSize) / clientScale);
		}


		// Translate the y coordinate to tile coordinates adjusted to the current transform
		const getTilePositionY = (event) => {
			return Math.floor((((getPositionY(event) / canvas.height) * sandArrayY) * inverseClientScale) - (clientYTranslate / pixelSize) / clientScale);
		}


		const moveDrawing = (event) => {
			if(drawing){
				event.preventDefault();

				// Calculate the mouse position
				let positionX = getTilePositionX(event);
                let positionY = getTilePositionY(event);

				// draw a line between the mouse points
				lineCalculator(lastPosition.x, lastPosition.y, positionX, positionY);

				// Set this point as the starting point for the next line segment
				lastPosition = {x: positionX, y: positionY};
			}
			else if(moving){
				// Calculate the mouse position
				let positionX = (getPositionX(event) * inverseClientScale) - (clientXTranslate / pixelSize) / clientScale;
				let positionY = (getPositionY(event) * inverseClientScale) - (clientYTranslate / pixelSize) / clientScale;
				
				// Add the amount moved to the translation value
				translateProccessX(positionX - lastMovePosition.x);
				translateProccessY(positionY - lastMovePosition.y);
				
				fullDraw();

				// Set this point as the starting point for the next line segment
				lastMovePosition = {x: positionX, y: positionY};
			}
		};


		// Set X translation
		const translateProccessX = (xShift) => {
			// Update the unscaled translate
			unScaledclientXTranslate += xShift;
			// Update the scaled translate
			clientXTranslate = (unScaledclientXTranslate * clientScale);
		}


		// Set Y translation
		const translateProccessY = (yShift) => {
			// Update the unscaled translate
			unScaledclientYTranslate += yShift;
			// Update the scaled translate
			clientYTranslate = (unScaledclientYTranslate * clientScale);
		}


		// Check that the tile should be sent
		const tileProccess = (x, y, tileType) => {
			// Add the tile to the list to be sent to the server,
			if(inBounds(x,y)){
				// Note for future development, place code here to avoid sending a tile if that tile already
				// exists in this spot but only if there arent tiles around that are likey to replace it.
				// without that extra step, it becomes noticably harder to draw over moving tiles.
				// Proposal: make a continuously updated array that lets the tiles check if they are bordered
				// by any tiles that are not the same as them.
				
				// Place the current pixel in the buffer
				outGoingTilesDict[`${x},${y}`] = {x: x, y: y, type: tileType};
			}
		}


		const activateDrawing = (event) => {

			// Calculate the mouse position
			let positionX = getTilePositionX(event);
            let positionY = getTilePositionY(event);

			// React to left click
            if(event.button === 0){
			  event.preventDefault();
			  drawing = true;

			  // Place the current pixel in the buffer
			  tileProccess(positionX, positionY, drawColor);

			  // Set this point as the starting point for the line.
			  lastPosition = {x: positionX, y: positionY};
			}
			// React to middle button click
			if(event.button === 1){
				event.preventDefault();
				// Set drawColor to the sand value of the currently selected tile
				drawColor = clientSandArray[positionX][positionY];
				// Update the selector value to reflect the current sand type
				document.querySelector("#sandType").value = drawColor;
			}
			// React to right button click
			if(event.button === 2){
				event.preventDefault();
				moving = true;

				let positionX = getPositionX(event);
				let positionY = getPositionY(event);

				positionX = (positionX * inverseClientScale) - (clientXTranslate / pixelSize) / clientScale;
				positionY = (positionY * inverseClientScale) - (clientYTranslate / pixelSize) / clientScale;
				lastMovePosition = {x: positionX, y: positionY};
				//lastMovePosition = {x: null, y: null};
			}
		};
		
		const activateTouchDrawing = (event) => {
			event.preventDefault();
			
			let positionX = getTilePositionX(event);
			let positionY = getTilePositionY(event);

			// Place the current pixel in the buffer
			outGoingTilesDict[`${positionX},${positionY}`] = {x: positionX, y: positionY, type: drawColor};
			
			// Set this point as the starting point for the line.
			lastPosition = {x: positionX, y: positionY};
		};
		
		const moveTouchDrawing = (event) => {
			event.preventDefault();
			
			let positionX = getTilePositionX(event);
			let positionY = getTilePositionY(event);

			// draw a line between the mouse points
			lineCalculator(lastPosition.x, lastPosition.y, positionX, positionY);
				
			// Set this point as the starting point for the line.
			lastPosition = {x: positionX, y: positionY};
		};
		
		const deactivateDrawing = (event) => {
			event.preventDefault();
			drawing = false;
			moving = false;
		};
		
		const edgeInDrawing = (event) => {
			if(drawing){
				event.preventDefault();
				// Calculate the mouse position
				let positionX = getTilePositionX(event);
				let positionY = getTilePositionY(event);
			
				// Set this point as the starting point for the line.
				lastPosition = {x: positionX, y: positionY};
			}
		};
		
		const edgeOutDrawing = (event) => {
			if(drawing){
				event.preventDefault();
				// Calculate the mouse position
				let positionX = getTilePositionX(event);
				let positionY = getTilePositionY(event);
			
				// draw a line between the mouse points
				lineCalculator(lastPosition.x, lastPosition.y, positionX, positionY);
			}
		};
		
		// Send the server the clients vote choice
		const stageChangeRequestCall = (event) => {
			// Send the request to clear the scene
			socket.emit('stageChangeRequest', parseInt(document.querySelector("#voteChoice").value));
		};
		
		// Request a redraw when focus is returned to the window
		const focusRedraw = () => {
			// Send the request to clear the scene
			socket.emit('fullUpdateRequest', {});
		};
		
		// React to scrolling action to scale the scene
		const wheel = (event) => {
			event.preventDefault();
			
			// Calculate the mouse position
			let positionX = getPositionX(event);
            let positionY = getPositionY(event);
			
			// Translations for the new center must be done in the context of the old scale window
			// so save the previous scale for later use
			let previousScale = clientScale;

			if(event.deltaY < 0){
				
				// Update the scale
				clientScale += zoomValue;
				//clientScale = clientScale*2;
				
				// Update the inverse for the new scale
				inverseClientScale = (1 / clientScale);

				// Use this copy if a zoom cap is implemented
				//translateProccessX(-(((canvas.width / 2) * inverseClientScale) / (previousScale / (clientScale - previousScale))));
				//translateProccessY(-(((canvas.height / 2) * inverseClientScale) / (previousScale / (clientScale - previousScale))));
				
				// Zoom from center
				//translateProccessX(-(((canvas.width / 2) * inverseClientScale) / (previousScale / zoomValue)));
				//translateProccessY(-(((canvas.height / 2) * inverseClientScale) / (previousScale / zoomValue)));
				
				translateProccessX(-((positionX * inverseClientScale) / (previousScale / zoomValue)));
				translateProccessY(-((positionY * inverseClientScale) / (previousScale / zoomValue)));
			}
			else{
				
				// Update the scale
				clientScale -= zoomValue;
				
				// Update the inverse for the new scale
				inverseClientScale = (1 / clientScale);
				
				if (clientScale < 1){
					clientScale = 1;
					inverseClientScale = 1;
				}
				
				if(previousScale !== clientScale){
					// Zoom out from mouse position
					//unScaledclientXTranslate += (((canvas.width - positionX) * inverseClientScale) / (previousScale / (previousScale - clientScale)));
					//unScaledclientYTranslate += (((canvas.height - positionY) * inverseClientScale) / (previousScale / (previousScale - clientScale)));
					
					// Zoom out from center of current view
					//unScaledclientXTranslate += (((canvas.width / 2) * inverseClientScale) / (previousScale / (previousScale - clientScale)));
					//unScaledclientYTranslate += (((canvas.height / 2) * inverseClientScale) / (previousScale / (previousScale - clientScale)));
					
					translateProccessX(((canvas.width / 2) * inverseClientScale) / (previousScale / (previousScale - clientScale)));
					translateProccessY(((canvas.height / 2) * inverseClientScale) / (previousScale / (previousScale - clientScale)));
				}
			}

			// Redraw the scene with the new transform
			fullDraw();
		};
		
		const init = () => {
			// Prevent default right click behavior
			canvas.oncontextmenu = function() {
				return false;
			}

			// define event for FireFox
			if (!event) {
				var event = window.Event;
			};

			connectSocket();
			canvas.onmousemove = moveDrawing.bind(event);
			canvas.ontouchmove = moveTouchDrawing.bind(event);
			canvas.onmousedown = activateDrawing.bind(event);
			window.onmouseup = deactivateDrawing.bind(event);
			canvas.ontouchstart = activateTouchDrawing.bind(event);
			//canvas.ontouchend = deactivateDrawing.bind(event);
			canvas.onmouseout = edgeOutDrawing.bind(event);
			canvas.onmouseover = edgeInDrawing.bind(event);
			window.onfocus = focusRedraw.bind();
			canvas.onwheel = wheel.bind(event);
			
			document.querySelector("#sandType").onchange = function(e){

				drawColor = parseInt(e.target.value);
			}
			
			const stageChangeRequest = document.querySelector("#voteScene");
			stageChangeRequest.addEventListener('click', stageChangeRequestCall);
			
			requestAnimationFrame(partialDraw);
		};
		
		// Add init to the functions to run with the onload event
		// credit for load code:
		// https://ckon.wordpress.com/2008/07/25/stop-using-windowonload-in-javascript/
		window.addEventListener ? 
		window.addEventListener("load",init,false) : 
		window.attachEvent && window.attachEvent("onload",init);
    </script>
</head>
<body>
	<canvas id="canvas">
		Your browser does not support the HTML5 canvas tag.
	</canvas>
	<div id="controls">
		<label>Sand Types
			<select id="sandType">
				<option value="4">Salt</option>
				<option value="6">Salt Water</option>
				<option value="2" selected>Sand</option>
				<option value="7">Seaweed</option>
				<option value="5">Stone</option>
				<option value="1">Void (Eraser)</option>
				<option value="3">Water</option>
			</select>
		</label>
		<div id="sceneVote">
			<div id="voteFiller">
				<label>Scenes Options
					<select id="voteChoice">
						<option value="0" selected>No Change</option>
						<option value="1">Clear</option>
						<option value="2">Lake floor</option>
						<option value="3">Water</option>
						<option value="4">Random Chaos</option>
					</select>
				</label>
				<input id="voteScene" type='button' value='Cast Vote'/>
			</div>
			<div id="voteResults">
				<div id="voteClear">
					<span>Clear Total: </span>
					<span id="clearCount"></span>
					<progress id="clearProgress" value="0" max="100"></progress>
				</div>
				<div id="voteLakeFloor">
					<span>Lake Floor Total: </span>
					<span id="lakeFloorCount"></span>
					<progress id="lakeFloorProgress" value="0" max="100"></progress>
				</div>
				<div id="voteWater">
					<span>Water Total: </span>
					<span id="waterCount"></span>
					<progress id="waterProgress" value="0" max="100"></progress>
				</div>
				<div id="voteRandom">
					<span>Random Chaos Total: </span>
					<span id="randomCount"></span>
					<progress id="randomProgress" value="0" max="100"></progress>
				</div>
			</div>
		</div>
		<div id="players">
			<span>Players Online: </span>
			<span id="playerCount"></span>
		<div>
	</div>
</body>
</html>
























